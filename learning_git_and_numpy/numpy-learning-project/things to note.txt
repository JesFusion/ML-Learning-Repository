{
    1. np.random.rand() is for uniform distribution

    2. np.random.randn() is for normal distribution
},

{
    "Here are the legacy methods for creating random NumPy arrays using the np.random. notation:"

    np.random.rand(d0, d1, ...): generates an array of random floats from a uniform distribution over [0, 1), taking dimensions as separate arguments.
    float_array = np.random.rand(3, 2)


    np.random.random(size) generates an array of random floats from a uniform distribution over [0.0, 1.0), taking the shape as a tuple or int.
    float_array_2 = np.random.random(size=(3, 2))


    np.random.randn(d0, d1, ...) generates an array of random floats from a standard normal distribution (mean 0, stdev 1), taking dimensions as separate arguments.
    normal_array = np.random.randn(3, 3)


    np.random.randint(low, high, size) generates an array of random integers from low (inclusive) to high (exclusive).
    int_array = np.random.randint(0, 10, size=(1, 5))


    np.random.normal(loc, scale, size) generates an array of random floats from a normal distribution with specified mean (loc) and standard deviation (scale).
    normal_array_2 = np.random.normal(loc=0.0, scale=1.0, size=(3, 3))


    np.random.uniform(low, high, size) generates an array of random floats from a uniform distribution within a specified range [low, high).
    uniform_array = np.random.uniform(5.0, 10.0, size=(2, 2))

    
    np.random.choice(a, size) generates a random sample from a given 1-D array or sequence a.
    sample_array = np.random.choice(['apple', 'banana', 'cherry'], size=3)
},

{
    "Text Styling:"

    - Bold: **text** or __text__

    - Italic: *text* or _text_
    
    - Strikethrough: ~~text~~

    - Bold and Italic (nested): **_text_** or ***text***

    - Subscript: <sub>text</sub> (using inline HTML)

    - Superscript: <sup>text</sup> (using inline HTML)
    
    - Underline: <ins>text</ins> (using inline HTML) 
    
    
    "Headings and Structure:"
    - Headings: Use # symbols (H1 to H6)
    # Heading 1
    ## Heading 2
    
    - Paragraphs: Separate text with a blank line.
    
    - Line Breaks: In an .md file, use two trailing spaces or a backslash at the end of a line, or a blank line for a new paragraph.

    - Horizontal Rule: Three or more hyphens (---), asterisks (***), or underscores (___) on a line by themselves.


    "Lists:"
    - Unordered List: Start a line with *, -, or +.

    - Ordered List: Start a line with a number followed by a period (e.g., 1.).

    - Nested Lists: Indent list items with spaces (typically 2 or 4, depending on context).

    - Task Lists (GFM extension): Add checkboxes to list items.
    - [x] Completed task
    - [ ] Incomplete task


    "Links and Images:"
    - Links: [Link text](URL) or automatic linking for raw URLs (<http://example.com>).
    
    - Images: ![Alt text](Image URL).

    - Relative Links: Links to other files within the same repository automatically work. 

    
    "Code and Quoting:"
    - Inline Code: Enclose text in single backticks (`code`).
    
    - Fenced Code Blocks: Enclose blocks of code in triple backticks (```).

    - Syntax highlighting is supported by specifying the language after the opening backticks:
    ```python.
    Blockquotes: Preface text with >.
    > Quoted text
    ```
},


{
    There are 3 simple BroadCasting rules. NumPy compares the shapes of your two arrays (e.g., A and B) from right to left.

    - Rule 1: Align shapes from the right.

    A: (4, 3, 2)

    B: ( , 3, 2) (If B's shape is (3, 2))

    A: (4, 3, 2)

    B: ( , 2) (If B's shape is (2,))

    
    
    
    - Rule 2: Check if dimensions are compatible.

    Starting from the right, each pair of dimensions must be compatible. A pair is "compatible" if:

    The dimensions are equal (e.g., 2 vs 2), OR

    One of the dimensions is 1.

    
    
    
    - Rule 3: "Stretch" (broadcast) the dimension of size 1.

    If a pair is compatible because one of them is 1, NumPy "stretches" that 1 to match the other dimension.




    `Examples:`
    - Example 1: Success (The "Paint Roller") A (3, 3) + B (3, 1)

    Align: A: (3, 3) B: (3, 1)

    Check (Right-to-Left):

    3 vs 1: Compatible! (Rule 2)

    3 vs 3: Compatible! (Rule 2)

    Stretch:

    NumPy stretches B's shape from (3, 1) to (3, 3).

    Result: SUCCESS! (This is our "smart paint roller" from last lesson).

    

    
    - Example 2: Success (The "Row Vector") A (3, 3) + B (3,)

    Align: A: (3, 3) B: ( , 3)

    Check (Right-to-Left):

    3 vs 3: Compatible! (Rule 2)

    3 vs (empty): Compatible! (NumPy treats "empty" as 1. This is Rule 2).

    Stretch:

    NumPy first promotes B's shape to (1, 3).

    It then stretches this (1, 3) shape to (3, 3).

    Result: SUCCESS! (This is our "row vector" add from last lesson).

    
    
    
    
    - Example 3: FAILURE (The "Why it breaks") A (3, 4) + B (3,)

    Align: A: (3, 4) B: ( , 3)

    Check (Right-to-Left):

    4 vs 3: INCOMPATIBLE! (They are not equal, and neither is 1).

    Result: ERROR! ValueError: operands could not be broadcast together with shapes (3,4) (3,)
}

{
    samples = rows

    features = columns
},

{
    NEVER, EVER, EVER use "git reset --hard" on a branch that you have pushed and shared with a team (like main). If you do, you're "burning" pages that your teammates might have!
},


{
    NEVER rebase a public branch (like main). Only rebase your own local feature branches before you push them. Rewriting public history breaks everyone else's work.
}